// Copyright 2025 The Atlantis Authors
// SPDX-License-Identifier: Apache-2.0

package events

import (
	"fmt"

	"github.com/runatlantis/atlantis/server/events/command"
	"github.com/runatlantis/atlantis/server/events/vcs"
	"github.com/runatlantis/atlantis/server/utils"
)

// aiSummarySplitThreshold: when combined AI summary + plan details would exceed
// this, we post them as two separate comments so the summary stays visible as
// markdown. Conservative (below typical VCS limits) so we split early rather than
// risk hitting the limit and having the underlying split put summary in "Show Output".
const aiSummarySplitThreshold = 50000

type PullUpdater struct {
	HidePrevPlanComments bool
	VCSClient            vcs.Client
	MarkdownRenderer     *MarkdownRenderer
}

func (c *PullUpdater) updatePull(ctx *command.Context, cmd PullCommand, res command.Result) {
	// Log if we got any errors or failures.
	if res.Error != nil {
		ctx.Log.Err(res.Error.Error())
	} else if res.Failure != "" {
		ctx.Log.Warn(res.Failure)
	}

	// HidePrevCommandComments will hide old comments left from previous runs to reduce
	// clutter in a pull/merge request. This will not delete the comment, since the
	// comment trail may be useful in auditing or backtracing problems.
	if c.HidePrevPlanComments {
		ctx.Log.Debug("hiding previous plan comments for command: '%v', directory: '%v'", cmd.CommandName().TitleString(), cmd.Dir())
		if err := c.VCSClient.HidePrevCommandComments(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull.Num, cmd.CommandName().TitleString(), cmd.Dir()); err != nil {
			ctx.Log.Err("unable to hide old comments: %s", err)
		}
	}

	if len(res.ProjectResults) > 0 {
		var commentOnProjects []command.ProjectResult
		for _, result := range res.ProjectResults {
			if utils.SlicesContains(result.SilencePRComments, cmd.CommandName().String()) {
				ctx.Log.Debug("silenced command '%s' comment for project '%s'", cmd.CommandName().String(), result.ProjectName)
				continue
			}
			commentOnProjects = append(commentOnProjects, result)
		}

		if len(commentOnProjects) == 0 {
			return
		}

		res.ProjectResults = commentOnProjects
	}

	comment := c.MarkdownRenderer.Render(ctx, res, cmd)

	// Add OpenRouter summary for plan commands
	if cmd.CommandName() == command.Plan {
		var terraformOutputs []string
		for _, result := range res.ProjectResults {
			if result.PlanSuccess != nil {
				terraformOutputs = append(terraformOutputs, result.PlanSuccess.TerraformOutput)
			}
		}

		if len(terraformOutputs) > 0 {
			summary := SummarizePlans(terraformOutputs, ctx.Log)
			if summary != "" {
				summaryBlock := fmt.Sprintf("### Plan Summary (AI generated by Topher's AI)\n\n%s", summary)
				planBlock := fmt.Sprintf("### Regular Atlantis Plan Details\n\n%s", comment)
				combined := fmt.Sprintf("%s\n\n---\n\n%s", summaryBlock, planBlock)
				if len(combined) > aiSummarySplitThreshold {
					// Post summary and plan details as two comments so the AI summary
					// stays visible as markdown; the underlying VCS split would put
					// continuation in "Show Output" / diff.
					if err := c.VCSClient.CreateComment(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull.Num, summaryBlock, cmd.CommandName().String()); err != nil {
						ctx.Log.Err("unable to comment (summary): %s", err)
						return
					}
					comment = planBlock
				} else {
					comment = combined
				}
			}
		}
	}

	if err := c.VCSClient.CreateComment(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull.Num, comment, cmd.CommandName().String()); err != nil {
		ctx.Log.Err("unable to comment: %s", err)
	}
}
